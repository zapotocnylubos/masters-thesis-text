\chapter{Frama-C}
\label{ch:frama-c}

V oblasti formální verifikace softwaru hrají významnou roli nástroje umožňující
statickou analýzu zdrojového kódu a deduktivní dokazování správnosti těchto programů.
Mezi ustálené platformy zaměřené na analýzu programů napsaných v jazyce C patří prostředí Frama\mbox{-}C,
které poskytuje užitečné nástroje a možnost rozšíření o moduly a pluginy~\cite{FCKernelMaroneze2024}.
Frama\mbox{-}C je open-source nástroj, který byl vyvinut na výzkumném ústavu CEA-LIST (Commissariat à l'Énergie Atomique et aux Énergies Alternatives)
a první verze byla vydána v roce 2008.

Jádro Frama\mbox{-}C je napsáno v jazyce OCaml a je postaveno jako modulární framework
navržený s cílem usnadnit aplikaci pokročilých technik formální analýzy nad programy v jazyce C
pomocí integrace různých analytických nástrojů ve formě pluginů~\cite{FCPluginDevSignoles2024}.
Některé z těchto pluginů jsou obsaženy přímo v jádře Frama\mbox{-}C, zatímco další jsou dostupné jako externí moduly.
Moduly obsažené v jádře Frama\mbox{-}C zahrnují například deduktivní analyzátor WP (Weakest Precondition)
založený na teoretickém základu popsaném v kapitole~\ref{ch:metoda-nejslabsiho-predpokladu},
RTE (Run-Time Error) pro detekci chyb při běhu programu, který si představíme v kapitole~\ref{sec:frama-c-rte},
nebo například EVA (Evolving Value Analysis) pro analýzu hodnot proměnných v průběhu vykonávání programu.

Klíčovým prvkem Frama\mbox{-}C je definice a podpora specifikačního jazyka ACSL (ANSI/ISO C Specification Language),
který umožňuje uživatelům vyjadřovat vlastnosti a specifikace programů v jazyce C pomocí specifikačních komentářů.
Tyto komentáře anotují kód a poskytují informace pro statickou analýzu a deduktivní dokazování.
Návrh a implementace ACSL byly inspirovány podobným standardem pro jazyk Java, známým jako JML (Java Modeling Language)~\cite{ACSLSpec}.
ACLS bude podrobněji představen v kapitole~\ref{sec:acsl}.

Prostředí Frama\mbox{-}C je distribuováno jako program pro příkazový řádek a také jako grafické uživatelské rozhraní (GUI).
GUI poskytuje uživatelsky přívětivé prostředí pro interakci s celým ekosystémem Frama\mbox{-}C a hlavně s nainstalovanými pluginy.
Grafické prostředí je dostupné hlavně pro operační systémy Linux a Windows.
Pro uživatele operačního systému macOS je k dispozici pouze příkazová řádka.

Organizace stojící za vývojem Frama\mbox{-}C distribuuje mimo jiné také Docker image, které obsahují všechny potřebné závislosti
pro běh Frama\mbox{-}C a základních pluginů společně s několika SMT řešičemi, jako je Alt-Ergo, CVC4 a Z3.
Také distribuují GUI variantu imagů a je tedy velmi snadné spustit Frama\mbox{-}C GUI pomocí Dockeru na libovolném operačním systému,
jako je například macOS nebo Windows.
Tyto image obsahují minimalistické desktopové prostředí, Frama\mbox{-}C GUI a VNC aplikaci
umožnující připojení k desktopovému prostředí pomocí webového prohlížeče~\cite{FCDockerGUIMaroneze2021}.


\section{ACSL (ANSI/ISO C Specification Language)}
\label{sec:acsl}

ACLS je specifikační jazyk pro jazyk C, který umožňuje uživatelům
vyjadřovat vlastnosti a specifikace programů pomocí anotací v podobě speciálních komentářů ve zdrojovém kódu.

Anotace lze zapsat jako jednořádkový komentář \texttt{//@ ...} nebo víceřádkový komentář \texttt{/*@ ... */}.
Tyto anotace jsou umístěny přímo ve zdrojovém kódu a vypadají například jako v ukázce~\ref{list:acsl-example}.

\begin{listing}[H]
    \begin{minted}{C}
    /*@ requires x > 0;
        assigns \result;
        ensures \result == x + 2;
    */
    int increment(int x) {
        x = x + 1;
        //@ assert x > 1;
        return x + 1;
    }
    \end{minted}
    \caption{Ukázka anotace funkce v jazyce C pomocí ACSL}
    \label{list:acsl-example}
\end{listing}

V návaznosti na kapitolu~\ref{ch:metoda-nejslabsiho-predpokladu}, kde jsme se seznámili
s metodou nejslabšího předpokladu, si nyní ukážeme, jakým způsobem lze pomocí ACSL
vyjádřit vlastnosti, předpoklady a závěry pro funkce v jazyce C.

V ukázce~\ref{list:acsl-example} je uvedena funkce \texttt{increment}, která
definuje předpoklad a závěř pomocí klíčových slov \texttt{requires} a \texttt{ensures}.
Zjednodušená Hoaerova trojice pro příklad z kódu~\ref{list:acsl-example} vypadá následovně:

\begin{equation*}
    \{ x > 0 \} \ (x = x + 1; return \  x + 1) \ \{ result == x + 2 \}
\end{equation*}

Frama\mbox{-}C před spuštěním analýzy převede zdrojový kód do mezi-interpretace (intermediate representation)
nazývané \texttt{CIL} (C Intermediate Language)~\cite{BlanchardACSL2024}.
Frama\mbox{-}C používá vlastní verzi \texttt{CIL}, která je založena na původní verzi, kterou vytvořil George Necula~\cite{Necula2002CIL}.
Od roku 2016 tato původní verze již není udržována, ale Frama\mbox{-}C stále podporuje vlastní verzi.

Výhodou vlastního předzpracování a použití mezi-interpretace je,
že Frama\mbox{-}C může analyzovat zdrojový kód efektivně
a nainstalované pluginy mohou pracovat s touto abstraktní reprezentací
a nebo ji dokonce upravovat či transformovat~\cite{FCKernelMaroneze2024}.


\subsection{Anotace \texttt{\textbackslash at} a časové body}
\label{subsec:anotace-at-a-casove-body}

Anotaci \texttt{\textbackslash at(\dots, L)} můžeme využít pro odkazování na hodnoty proměnných
v různých časových bodech programu označených jako $L$.
Návěští (label) $L$ může být například začátek funkce, začátek cyklu nebo libovolné místo v programu,
které je ve zdrojovém kódu explicitně označeno.
Uživatelem definovaná návěští jsou standardní součástí jazyka C
a Frama\mbox{-}C je používá pro specifikaci časových bodů v programu.

Následující příklad~\ref{list:label-example} zobrazuje kód,
ve kterém jsou explicitně definovaná dvě návěští \texttt{L0} a \texttt{L1}.
Odkazovat se na hodnoty proměnných v časových bodech definovanými těmito návěštími
je možné pomocí anotace \texttt{\textbackslash at(\dots, L0)} a \texttt{\textbackslash at(\dots, L1)}.

\begin{listing}[H]
    \begin{minted}{C}
    void calc(int x) {
        L0:
        x++;
        L1:
        x += 2;
        //@ assert x >= \at(x, L0) + 3;
        //@ assert x >= \at(x, L1) + 2;
    }
    \end{minted}
    \caption{Ukázka uživatelského návěští v Frama-C}
    \label{list:label-example}
\end{listing}

Frama\mbox{-}C také poskytuje implicitní návěští,
která jsou automaticky generována a jejich časový bod je definován
standardem podle toho, kde se anotace nachází.
Konrkrétně jsou k dispozici tato implicitní návěští~\cite{ACSLSpec}:

\begin{itemize}
    \item \textbf{Pre}
    \begin{itemize}
        \item Použitelné pouze v anotacích příkazů, nikoliv v kontraktech funkcí.
        \item Odkazuje na stav před začátkem funkce, ve které se anotace nachází.
    \end{itemize}

    \item \textbf{Post}
    \begin{itemize}
        \item Použitelné pouze v kontraktech funkcí v klauzulích \texttt{assigns} a \texttt{ensures}.
        \item Odkazuje na stav po ukončení funkce, ve které se anotace nachází.
    \end{itemize}

    \item \textbf{Here}
    \begin{itemize}
        \item Použitelné v anotacích příkazů i kontraktech funkcí.
        \item U klauzulí \texttt{requires}, \texttt{assumes}, \texttt{assigns}, \texttt{frees}, \texttt{decreases}, \texttt{terminates} odkazuje na \texttt{Pre} stav.
        \item U klauzulí \texttt{ensures}, \texttt{allocates} a při ukončení s výjimkou odkazuje na \texttt{Post} stav.
        \item V ostatních klauzulích odkazuje na aktualní stav v místě, kde se anotace nachází.
    \end{itemize}

    \item \textbf{LoopEntry}
    \begin{itemize}
        \item Použitelné v anotacích cyklů.
        \item Odkazuje na stav před provedením prvním iterace cyklu.
    \end{itemize}

    \item \textbf{LoopCurrent}
    \begin{itemize}
        \item Použitelné v anotacích cyklů.
        \item Odkazuje na stav před provedením aktuální iterace cyklu.
    \end{itemize}

    \item \textbf{Old}
    \begin{itemize}
        \item Použitelné v anotacích příkazů i kontraktech funkcí.
        \item U klauzulí \texttt{assigns} a \texttt{ensures} odkazuje na stav před provedením funkce.
        \item Oproti \texttt{Pre} lze \texttt{Old} použít i v kontraktech funkcí.
        \item ACSL definuje \texttt{\textbackslash old(x)} jako syntaktický cukr pro \texttt{\textbackslash at(x, Old)}.
    \end{itemize}
\end{itemize}

TODO: pointery a validita, separace

TODO: kvantifikátory, predikáty, logické funkce

TODO: loop invarianty, loop varianty

TODO: ghost konstrukty

\section{RTE (Run-Time Error)}
\label{sec:frama-c-rte}


\section{WP (Weakest Precondition)}
\label{sec:frama-c-wp}


\section{Paměťové modely}
\label{sec:frama-c-mem}

% TODO: objasnit co znamená ...chovají vzhledem k paměti...
Paměťové modely jsou důležitou součástí analýzy programů,
protože umožňují definovat, jakým způsobem se programy chovají
vzhledem k paměti a jakým způsobem manipulují s daty.

Paměťové modely popisují způsob popisu operace na

\subsection{Hoaerův paměťový model}
\label{subsec:hoaeruv-pametovy-model}

Nejjednodušší paměťový model je Hoareův paměťový model,
ve kterém se operace s pamětí provádějí pomocí přiřazení do logických proměnných.
Jedná se o aplikaci metody Single Static Assignment (SSA),
která zajišťuje, že každá logická proměnná má přiřazenou hodnotu pouze jednou.

Hoaerův paměťový model reprezentuje proměnné a jejich hodnoty v různých časech
pomocí několika různých logických proměnných, na které lze odkazovat pomocí
ACLS anotace \texttt{\textbackslash at}.
Tato anotace, její použití a význam byly podrobněji popsány v kapitole~\ref{subsec:anotace-at-a-casove-body}.

Následující příklad~\ref{list:ssa-example} popisuje velmi jednoduchou funkci,
která přijímá jeden parametr $x$ typu \texttt{int} (celé číslo) a provádí na něm dvě operace.
První operace zvyšuje hodnotu $x$ o 1 a druhá operace zvyšuje hodnotu $x$ o 2.
Provedením těchto operací se tedy hodnota proměnné $x$ zvětší o 3.
Pomocí anotace \texttt{\textbackslash at(x, Pre)} popisujeme počáteční hodnotu proměnné $x$,
tedy původní hodnotu parametru funkce.

\begin{listing}[H]
    \begin{minted}{C}
    void calc(int x) {
        x++;
        x += 2;
        //@ assert x >= \at(x, Pre) + 3;
    }
    \end{minted}
    \caption{Zdrojový kód pro ukázku Single Static Assignment}
    \label{list:ssa-example}
\end{listing}

Pomocí Frama\mbox{-}C lze nahlédnout na interní reprezentaci proměnných pomocí příkazu~\ref{list:ssa-example-run}.
Tento příkaz spustí analýzu zdrojového kódu v souboru \texttt{ssa.c} pomocí metody nejslabšího předpokladu.
Dále explicitně specifikujeme, že chceme použít paměťový model \texttt{Hoare},
jelikož Frama\mbox{-}C podporuje více paměťových modelů a výchozím modelem je \texttt{Typed},
který je popsán v následující kapitole~\ref{subsec:typovy-pametovy-model}.
Přepínač \texttt{-wp-no-let} zakazuje zjednodušování pomocí propagace rovnosti a substituce,
bez kterého by výstup byl pouze označen za platný (valid) interním Qed zjednodušovačem (simplifier).
Qed se používá pro zjednodušení dotazů pro SMT řešiče a v triviálních případech dokáže sám ověřit platnost dotazu~\cite{WPManual, BlanchardWP2024}.
Pomocí přepínače \texttt{-wp-print} specifikujeme, že chceme zobrazit detaily analýzy a vypsat je na standardní výstup.

\begin{listing}[H]
    \begin{minted}{console}
    frama-c -wp -wp-model Hoare -wp-no-let -wp-print ssa.c
    \end{minted}
    \caption{Příkaz pro zobrazení interní reprezentace proměnných}
    \label{list:ssa-example-run}
\end{listing}

Výstup analýzy~\ref{list:ssa-frama-c} potvrzuje využití principu Single Static Assignment
a zobrazuje interní reprezentaci programu jako několik přiřazení do logických proměnných $x_i$.
Logické proměnné jsou číslované ve vzestupném pořadí a číslují se v obráceném pořadí, než v jakém byly přiřazeny.
Tedy poslední přiřazení do proměnné $x$ je reprezentováno proměnnou $x_1$, předposlední přiřazení $x_2$ a tak dále.
Samostatná logická proměnná $x$ reprezentuje hodnotu proměnné $x$ před prvním přiřazením,
tedy na začátku funkce a jedná se o hodnotu proměnné $x$, kterou získáváme voláním \texttt{\textbackslash at(x, Pre)}.

\begin{listing}[H]
    \begin{minted}{text}
    Goal Assertion (file ssa.c, line 4):
    Assume {
      Type: is_sint32(x_1) /\ is_sint32(x)
            /\ is_sint32(x_2) /\ is_sint32(x_3).
      Have: x_3 = x.
      Have: (1 + x_3) = x_2.
      Have: (2 + x_2) = x_1.
    }
    Prove: (3 + x) <= x_1.
    Prover Qed returns Valid
    \end{minted}
    \caption{Interní reprezentace proměnných pomocí Hoareova paměťového modelu}
    \label{list:ssa-frama-c}
\end{listing}

% TODO: ukázat IF-Then-Else SSA

Hoareův paměťový model je velmi jednoduchý a efektivní na základní práci s proměnnými, ale má také své nevýhody.
Hlavní nevýhodu popsal sám Hoare v roce 1969, který ve svém článku~\cite{Hoare1969} uvádí,
že tento model je nevhodný na analýzu kódu, který pracuje s ukazateli, dynamickou pamětí a možným aliasingem.
Problém při modelování ukazatelů nastává v okamžiku,
kdy paměťové místo (například proměnná) může být modifikováno z více než jednoho místa v programu (aliasing).
Tento problém je způsoben tím, že Hoareův paměťový model modeluje každou proměnnou odděleně.
Tedy proměnná typu \texttt{int}, například $x$, je reprezentována jako jedno paměťové místo,
a proměnná typu \texttt{int*}, například $px$, jako jiné paměťové místo a nepředpokládá se,
že by program prováděl nepřímou úpravu paměťi (například proměnné $x$) pomocí paměťové adresy
uložené v jiné proměnné (například $px$).

Pokud použijeme Hoaerův paměťový model na programy, které pracují s ukazateli,
můžeme dostat neplatné výsledky, které neodpovídají skutečnému chování programu.
Následující příklad~\ref{list:ssa-pointer-invalid-example} ukazuje jednoduchou funkci,
která přiřazuje hodnotu 1 do proměnné $x$ pomocí ukazatele $p$.

Po přiřazení je provedena kontrola, zdali hodnota v proměnné $x$ je 0.
Tento program ale vždy uloží do proměnné $x$ hodnotu 1 (přes ukazatel $p$),
ale pokud budeme chování programu analyzovat pomocí Hoareova paměťového modelu,
zjistíme, že model o změně hodnoty proměnné $x$ pomocí ukazatele $p$ neví
a výsledek analýzy~\ref{list:ssa-pointer-invalid-example-result} bude označený jako platný (valid),
což je v rozporu se skutečným chováním programu.

\begin{listing}[H]
    \begin{minted}{C}
    void calc() {
        int x = 0;
        int *p = &x;

        *p = 1;
        //@ assert x == 0;
    }
    \end{minted}
    \caption{Nesprávné použití Hoareova paměťového modelu na kód s ukazateli}
    \label{list:ssa-pointer-invalid-example}
\end{listing}

\begin{listing}[H]
    \begin{minted}{text}
    Goal Assertion (file hoare-wrong-when-pointer.c, line 6):
    Assume { Type: is_sint32(x). (* Initializer *) Init: x = 0. }
    Prove: x = 0.
    Prover Qed returns Valid
    \end{minted}
    \caption{Nesprávný výsledek analýzy pomocí Hoareova paměťového modelu}
    \label{list:ssa-pointer-invalid-example-result}
\end{listing}

Pro práci s programy, které obsahují ukazatele a dynamickou paměť,
tedy Hoareův paměťový model není vhodný.
Proto Frama\mbox{-}C podporuje také jiné paměťové modely,
které jsou schopny správně reprezentovat chování programu, i když s některými omezeními.
V následující kapitole~\ref{subsec:typovy-pametovy-model} si představíme typový paměťový model,
který Frama\mbox{-}C používá jako výchozí paměťový model a pro většinu programů by měl být dostačující.

\subsection{Typový paměťový model}
\label{subsec:typovy-pametovy-model}

% TODO: unifikovat mluveni, nerikat Představíme, ale neco univerzalniho a asi v jednotnem cisle

Typový paměťový model je výchozím paměťovým modelem Frama\mbox{-}C
a je navržen tak, aby byl schopen správně reprezentovat chování programů,
které obsahují ukazatele, dynamickou paměť a aliasing.
Představíme si zjednodušený paměťový model a následně tento model rozšíříme na typový paměťový model.


TODO

Zjednodušený paměťový model se odlišuje od Hoareova paměťového modelu tím,
že místo reprezentace proměnných jako logických proměnných
používá globální paměťovou mapu a operaci čtení a zápisu v této mapě.
Operace čtení paměťového místa $a$ z paměti $M$ je reprezentována zápisem \texttt{M[a]},
Operace zápisu hodnoty $v$ do paměťového místa $a$ v paměti $M$ je reprezentována zápisem \texttt{M[a <- v]}.

% TODO: replace <- with \leftarrow

Podobně jako v Hoareově paměťovém modelu,
i v tomto modelu nalezneme možnost odkazovat se na stav paměti (paměťové mapy)
v různých časových bodech pomocí anotace \texttt{\textbackslash at}.
Princip Single Static Assignment (SSA) je zachován, ale na úrovni celé paměťové mapy.
Každý zápis do paměti vytvoří novou paměťovou mapu,
která se odlišuje od původní paměťové mapy pouze tím,
že obsahuje novou hodnotu na daném paměťovém místě.
Paměťová mapa je tedy immutabilní a každá modifikace paměti vytvoří novou paměťovou mapu.
Formálně je tedy operace zápisu hodnoty $v$ na paměťové místo $a$ v paměti $M$ reprezentována zápisem
\texttt{M[a <- v] = M'}, kde $M'$ je nová paměťová mapa.
Takto upravené paměťové mapy jsou indexované podobně jako logické proměnné v Hoareově paměťovém modelu,
s tím rozdílem, že paměťové mapy jsou číslovány vzestupně dle pořadí výskytu modifikace paměti,
tedy první přiřazení do paměťové mapy vygenerovalo mapu $M_2$ z iniciální paměti $M_1$,
další přiřazení do paměti vygenerovalo mapu $M_3$ z mapy $M_2$ a tak dále.
Poslední přiřazení do paměti vygeneruje mapu $M_0$ z mapy $M_n$ po n-tém přiřazení do paměti.

Následující kód~\ref{list:typed-assign-example} ukazuje jednoduchou funkci,
která přiřazuje hodnoty do proměnné na kterou ukazuje ukazatel $p$.
Provádí se celkem čtyři přiřazení do paměti a na konci funkce je provedena kontrola,
zdali je hodnota proměnné $p$ rovná 2.
Pomocí Frama\mbox{-}C lze nahlédneme na interní reprezentaci
a operace s paměťovým modelem pomocí příkazu~\ref{list:typed-assign-example-run}.

\begin{listing}[H]
    \begin{minted}{C}
    void calc(int *p) {
        *p = -1;
        *p = 0;
        *p = 1;
        *p = 2;
        //@ assert *p == 2;
    }
    \end{minted}
    \caption{Ukázka modifikace paměti pomocí typového paměťového modelu}
    \label{list:typed-assign-example}
\end{listing}

\begin{listing}[H]
    \begin{minted}{console}
    frama-c -wp -wp-model Typed \
      -wp-no-let -wp-print mem-map-example.c
    \end{minted}
    \caption{Příkaz pro zobrazení interní reprezentace pomocí typového paměťového modelu}
    \label{list:typed-assign-example-run}
\end{listing}


Následující příklad~\ref{list:typed-pointer-valid-example} je téměř identický
s předchozím příkladem~\ref{list:ssa-pointer-invalid-example},
ale místo použití Hoareova paměťového modelu použijeme typový paměťový model
a místo kontroly, zda je hodnota proměnné $x$ 0 (což je v rozporu se skutečným chováním programu),
zkontrolujeme, zda je hodnota proměnné $x$ 1, což je očekávané chování programu.

\begin{listing}[H]
    \begin{minted}{C}
    void calc() {
        int x = 0;
        int *p = &x;

        *p = 1;
        //@ assert x == 1;
    }
    \end{minted}
    \caption{Správné použití typového paměťového modelu na kód s ukazateli}
    \label{list:typed-pointer-valid-example}
\end{listing}

Analýzu programu provedeme pomocí příkazu~\ref{list:typed-pointer-valid-example-run},
který spustí analýzu pomocí metody nejslabšího předpokladu s využitím typového paměťového modelu.

\begin{listing}[H]
    \begin{minted}{console}
    frama-c -wp -wp-model Typed \
      -wp-no-let -wp-print typed-correct-when-pointer.c
    \end{minted}
    \caption{Příkaz pro spuštění analýzy pomocí typového paměťového modelu}
    \label{list:typed-pointer-valid-example-run}
\end{listing}

Výstup analýzy~\ref{list:typed-pointer-valid-example-result} ukazuje,
že typový paměťový model správně reprezentuje chování programu,
tedy, že správně rozhoduje o platnosti (valid) dotazu na hodnotu proměnné $x$.

\begin{listing}[H]
    \begin{minted}{text}
    Goal Assertion (file typed-correct-when-pointer.c, line 6):
    Let a = global(L_x_24).
    Let x = Mint_0[a].
    Assume {
      Type: is_sint32(x).
      (* Heap *)
      Type: linked(Malloc_0) /\ cinits(Init_0).
      (* Block In *)
      Have: Malloc_0[L_x_24 <- 1] = Malloc_1.
      (* Initializer *)
      Init: (Init_0[a]=true).
      (* Initializer *)
      Init: Mint_1[a] = 0.
      (* Initializer *)
      Init: a = p.
      Have: (Init_0[p <- true] = Init_1)
              /\ (Mint_1[p <- 1] = Mint_0).
    }
    Prove: x = 1.
    Prover Qed returns Valid
    \end{minted}
    \caption{Správný výsledek analýzy pomocí typového paměťového modelu}
    \label{list:typed-pointer-valid-example-result}
\end{listing}


Aplikací typoveého


Ukazatel (pointer) je ve Frama\mbox{-}C reprezentován jako dvojice


\subsection{Referenční paměťový model}
\label{subsec:referencni-pametovy-model}

% TODO: jo?
% -wp-model <model+...>  Memory model selection. Available selectors:
% * 'Hoare' logic variables only
% * 'Typed' typed pointers only
% * '+nocast' no pointer cast
% * '+cast' unsafe pointer casts
% * '+raw' no logic variable
% * '+ref' by-reference-style pointers detection
% * '+nat/+int' natural / machine-integers arithmetics
% * '+real/+float' real / IEEE floating point arithmetics
% * 'Eva' (experimental) based on the results from Eva
% plugin (preferably use -wp-model="model+...")
% ====
%\subsection{Problémy paměťových modelů}

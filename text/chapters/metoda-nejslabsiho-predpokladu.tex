\chapter{Metoda nejslabšího předpokladu}
\label{ch:metoda-nejslabsiho-predpokladu}

Metoda nejslabšího předpokladu (weakest precondition, WP) je metoda,
používaná k algoritmickému dokazování správnosti programů pomocí Hoareovy logiky.
Formálně tuto metodu popsal E. W. Dijkstra v roce 1975 a navazuje na práci Hoareho~\cite{Dijkstra1975}.

Připomeneme, že Hoareova trojice je trojice $ \{ P \} \ Q \ \{ R \} $,
kde $P$ je předpoklad, $Q$ je příkaz a $R$ je následek.
Předpoklad $P$ je logický výraz, který musí být pravdivý před provedením příkazu $Q$.
Metoda nejslabšího předpokladu se snaží najít nejslabší předpoklad $WP$, pro který platí

\begin{equation*}
    \{ WP \} \ Q \ \{ R \}
\end{equation*}
a zároveň pro každý jiný předpoklad $P$, pro který by platilo, že

\begin{equation*}
    \{ P \} \ Q \ \{ R \}
\end{equation*}
musí také platit, že

\begin{equation*}
    P \implies WP.
\end{equation*}

Tedy, že $WP$ je nejslabší předpoklad pro příkaz $Q$ a následek $R$.

\begin{remark}
    Nejslabší předpoklad $WP$ je (logicky) unikátní pro daný příkaz $Q$ a následek $R$.
\end{remark}

Pokud by existoval jiný kandidát $WP'$ pro nejslabší předpoklad,
poté z definice platí, že

\begin{equation*}
    WP' \implies WP
\end{equation*}
a také, že

\begin{equation*}
    WP \implies WP'
\end{equation*}

Tedy musí platit, že $WP$ a $WP'$ jsou (logicky) ekvivalentní.

Nejslabší předpoklad $WP$ definujeme pomocí transformační funkce $\operatorname{wp}$,
s parametry $Q$ a $R$ následovně:

\begin{equation*}
    WP = \operatorname{wp}(Q, R)
\end{equation*}

Následující kapitoly představují základní pravidla pro algoritmický výpočet nejslabšího předpokladu.
Výpočet začíná vždy od následku $R$ a postupně (od konce k začátku)
analyzuje příkazy $Q_n, Q_{n-1}, \ldots, Q_1$ a aplikuje na ně specifická pravidla.
Výsledkem je nejslabší předpoklad $WP$ pro sekvenci příkazů $Q_1; Q_2; \ldots; Q_n$,
který následně použijeme pro formální důkaz správnosti programu.

\section{Pravidlo přiřazení}
\label{sec:pravidlo-prirazeni}

Výpočet nejslabšího předpokladu pro přiřazení proměnné $x$ hodnoty $E$ je
definován následovně:

\begin{equation*}
    \operatorname{wp}(x \coloneqq E, R) = R[x \leftarrow E],
\end{equation*}
kde $R[x \leftarrow E]$ je substituce výsktytu proměnné $x$ hodnotou $E$ v $R$.

Například pro příkaz $x \coloneqq x + 3$ a následek $x > 0$ dostáváme:

\begin{align*}
    \operatorname{wp}(x \coloneqq x + 3, x > 0) & = \\
                                 & = x + 3 > 0 \\
                                 & = x > -3
\end{align*}

Nejslabší předpoklad pro příkaz $x \coloneqq x + 3$, který zaručuje, že
následek $x > 0$ bude pravdivý, je tedy $x > -3$.

\section{Pravidlo sekvence}
\label{sec:pravidlo-sekvence}

Pravidlo sekvence napomáhá k určení nejslabšího předpokladu pro sekvenci příkazů.
Máme-li dva příkazy $Q_1$ a $Q_2$, které splňují následující tvrzení

\begin{equation*}
    \{ P_1 \} \  Q_1 \  \{ R_1 \}
\end{equation*}
a

\begin{equation*}
    \{ R_1 \} \  Q_2 \  \{ R_2 \}
\end{equation*}
můžeme říci, že nejslabší předpoklad pro sekvenci příkazů $Q_1; Q_2$ je

\begin{equation*}
    \operatorname{wp}(Q_1; Q_2, R) = \operatorname{wp}(Q_1, \operatorname{wp}(Q_2, R))
\end{equation*}

Podobně jako v pravidle skládání u Hoareovy logiky z kapitoly~\ref{sec:hoare-pravidlo-skladani}
můžeme rozmyslet výpočet nejslabšího předpokladu pro sekvenci příkazů $Q_1, Q_2, \ldots, Q_n$
pomocí asociativity operátoru $;$ a rekurzivního výpočtu nejslabšího předpokladu.

Například pro příkaz $x \coloneqq x + 3; y \coloneqq x + 2$ a následek $y > 0$ dostáváme:

\begin{align*}
    \operatorname{wp}(x \coloneqq x + 3; y \coloneqq x + 2, y > 0) & = \\
                                                     & = \operatorname{wp}(x \coloneqq x + 3, \operatorname{wp}(y \coloneqq x + 2, y > 0)) \\
                                                     & = \operatorname{wp}(x \coloneqq x + 3, x + 2 > 0) \\
                                                     & = x + 3 + 2 > 0 \\
                                                     & = x > -5
\end{align*}

Nejslabší předpoklad pro příkaz $x \coloneqq x + 3; y \coloneqq x + 2$, který zaručuje, že
následek $y > 0$ bude pravdivý, je tedy $x > -5$.

\section{Pravidlo podmínky}
\label{sec:pravidlo-podminky}

Pravidlo podmínky popisuje výpočet nejslabšího předpokladu pro podmínkový příkaz ve tvaru:

\begin{equation*}
    \textbf{if} \ B \ \textbf{then} \ Q_T \ \textbf{else} \ Q_F
\end{equation*}
kde $B$ je podmínka, $Q_T$ je příkaz, který se provede, pokud je podmínka $B$ pravdivá,
a $Q_F$ je příkaz, který se provede, pokud je podmínka $B$ nepravdivá.

Pravidlo podmínky je definováno následovně:

\begin{align*}
    \operatorname{wp}(\textbf{if} & \ B \ \textbf{then} \ Q_T \ \textbf{else} \ Q_F, R) = \\
                   & = (B \implies \operatorname{wp}(Q_T, R)) \land (\neg B \implies \operatorname{wp}(Q_F, R))
\end{align*}

Tedy nejslabší předpoklad pro podmínkový příkaz je logická konjunkce dvou implikací.
Nejslabší předpoklad totiž musí zahrnout oba možné stavy podmínky $B$, případ, kdy je $B$ pravdivá ale také případ, kdy je $B$ nepravdivá.

Pokud je podmínka $B$ pravdivá, použijeme nejslabší předpoklad pro příkaz~$Q_T$, tedy $\operatorname{wp}(Q_T, R)$.
Pokud není pravdivá ($\neg B$), použijeme nejslabší předpoklad pro příkaz~$Q_F$, tedy $\operatorname{wp}(Q_F, R)$.

Například pro příkaz $\textbf{if} \ x > 0 \ \textbf{then} \ y \coloneqq x + 3 \ \textbf{else} \ y \coloneqq x - 3$
a následek $y > 0$ dostáváme:

\begin{align*}
    \operatorname{wp}(\textbf{if} & \ x > 0 \ \textbf{then} \ y \coloneqq x + 3 \ \textbf{else} \ y \coloneqq x - 3, y > 0) = \\
          & = (x > 0 \implies \operatorname{wp}(y \coloneqq x + 3, y > 0)) \\
          & \ \ \ \ \land (\neg (x > 0) \implies \operatorname{wp}(y \coloneqq x - 3, y > 0)) \\
          & = (x > 0 \implies x + 3 > 0) \land (\neg (x > 0) \implies x - 3 > 0) \\
          & = (x > 0 \implies x > -3) \land (\neg (x > 0) \implies x > 3)
\end{align*}

Použitím pravidla implikace

\begin{align*}
    (P \implies A) \land (\neg P \implies B) & \iff (P \land A) \lor (\neg P \land B)
\end{align*}
můžeme původní výraz zjednodušit následovně:

\begin{align*}
    (x > 0 & \implies x > -3) \land (\neg (x > 0) \implies x > 3) = \\
           & = (x > 0 \land x > -3) \lor (\neg (x > 0) \land x > 3) \\
           & = (x > 0 \land x > -3) \lor (x \leq 0 \land x > 3) \\
           & = (x > 0 \land x > -3) \lor (\bot) \\
           & = x > 0 \land x > -3 \\
           & = x > -3
\end{align*}

Nejslabší předpoklad pro původní příkaz,
který zaručuje, že následek $y~>~0$ bude pravdivý, je tedy $x > -3$.
Poslední zjednodušení je možné provést, protože $x > 0$ je silnější předpoklad než $x > -3$,
platí že $x > 0 \implies x > -3$.

Zároveň jsme při výpočtu zjistili, že negativní část ($else$) podmínky nemá vliv na výpočet nejslabšího předpokladu,
protože neexistuje žádný předpoklad, který by v případě, že $x \leq 0$ a $y \coloneqq x - 3$, zaručoval, že $y > 0$.

\section{Pravidlo cyklu}
\label{sec:pravidlo-cyklu}

Pravidlo cyklu popisuje výpočet nejslabšího předpokladu pro cyklus ve tvaru:

\begin{equation*}
    \textbf{while} \ B \ \textbf{do} \ Q
\end{equation*}

Provést výpočet nejslabšího předpokladu pro cyklus je složitější než u ostatních příkazů,
jelikož není definované kolik iterací cyklus provede a nebo jestli vůbec cyklus někdy skončí.
Výpočet nejslabšího předpokladu pro cyklus lze rozdělit do dvou částí.
První část se zabývá výpočtem nejslabšího předpokladu bez ohledu na konečnost cyklu
a nazývá se částečná korektnost cyklu (partial correctness).
Druhá část se zabývá dokazováním konečnosti cyklu.
Pokud jsou o cyklu dokázány obě dvě části,
můžeme říci, že cyklus je plně korektní (total correctness)~\cite{arusoaie2024wp}.

Výpočet nejslabšího předpokladu při částečné korektnosti cyklu
definujeme pomocí funkce $\operatorname{wlp}$ (weakest liberal precondition).
Stejně jako u Hoareovy logiky je pro cykly nutné definovat invariant $I$.
Invariant je logický výraz, který musí být pravdivý před vstupem do cyklu (invariant establishment),
po ukončení každé iterace cyklu (invariant preservation) a tedy i po ukončení celého cyklu.
Funkci $\operatorname{wlp}$ lze definovat následovně:

\begin{align*}
    \operatorname{wlp}(\textbf{while} & \ B \ \textbf{do} \ Q, R) = \\
        & = I \land \forall y_1,\ldots,y_n \left( I \land B \implies \operatorname{wlp}(Q, I) \right)[x_1 \leftarrow y_1, \ldots, x_n \leftarrow y_n] \\
        & \ \ \ \  \land \forall y_1,\ldots,y_n \left( I \land \neg B \implies R \right)[x_1 \leftarrow y_1, \ldots, x_n \leftarrow y_n]
\end{align*}
kde $y_1, \ldots, y_n$ reprezentují stavy proměnných $x_1, \ldots, x_n$, které se v cyklu mohou měnit~\cite{arusoaie2024wp}.
Operace $[x_1 \leftarrow y_1, \ldots, x_n \leftarrow y_n]$ reprezentuje substituci proměnných $x_1, \ldots, x_n$ hodnotami $y_1, \ldots, y_n$.
První část konjunkce zajišťuje, že invariant $I$ je pravdivý před vstupem do cyklu,
druhá část zajištuje pravdivost invariantu $I$ na konci každé iterace cyklu
a třetí část zajišťuje, že pokud je invariant platný a cyklus skončil (podmínka $B$ je nepravdivá),
tak musí být pravdivý i následek $R$.

Například pro cyklus

\begin{equation*}
    \textbf{while} \ i < n \ \textbf{do} \ i \coloneqq i + 1
\end{equation*}
s následkem $R = i = n$ a invariantem $I = i \leq n$ dostáváme následující postup pro výpočet nejslabšího předpokladu:

\begin{align*}
    \operatorname{wlp}&(\textbf{while} \ i < n \ \textbf{do} \ i \coloneqq i + 1, i = n) = \\
        & = (i \leq n) \land \forall y_1 \left( (i \leq n) \land (i < n) \implies \operatorname{wlp}(i \coloneqq i + 1, i \leq n) \right)[i \leftarrow y_1] \\
        & \ \ \ \ \land \forall y_1 \left( (i \leq n) \land \neg (i < n) \implies i = n \right)[i \leftarrow y_1] \\
        & = (i \leq n) \land \forall y_1 \left( (y_1 \leq n) \land (y_1 < n) \implies \operatorname{wlp}(y_1 \coloneqq y_1 + 1, y_1 \leq n) \right) \\
        & \ \ \ \ \land \forall y_1 \left( (y_1 \leq n) \land \neg (y_1 < n) \implies y_1 = n \right) \\
        & = (i \leq n) \land \forall y_1 \left( (y_1 \leq n) \land (y_1 < n) \implies y_1 + 1 \leq n \right) \\
        & \ \ \ \ \land \forall y_1 \left( (y_1 \leq n) \land (y_1 \geq n) \implies y_1 = n \right) \\
        & = (i \leq n) \land \forall y_1 \left( y_1 < n \implies y_1 + 1 \leq n \right) \\
        & \ \ \ \ \land \forall y_1 \left( y_1 = n \implies y_1 = n \right) \\
        & = (i \leq n) \land \top \land \top \\
        & = i \leq n \\
\end{align*}
a tedy nejslabší předpoklad, který zaručuje, že následek $i = n$ spuštění cyklu bude pravdivý, je $i \leq n$.

Pokud bychom chtěli dokázat, že cyklus skončí, musíme cyklu přidat takzvaný variant.
Variant je celočíselný výraz, který se při každé iteraci cyklu snižuje.
Variant musí nabývat pouze nezáporných hodnot v průběhu cyklu.
Po ukončení cyklu může být variant i záporný.
Důležité na variantu je, že sleduje průběh iterací cyklu a pokud
je dokázáno, že se s každou iterací snižuje, můžeme říci, že cyklus je konečný.

Zavedení variantu $V$ a jeho aktuální hodnoty $v$ do výpočtu nejslabšího předpokladu by vypadalo následovně:

\begin{align*}
    \operatorname{wp}&(\textbf{while} \ B \ \textbf{do} \ Q, R) = \\
        & = I \land \forall y_1,\ldots,y_n,v \left( I \land B \land v = V \implies \operatorname{wp}(Q, I \land V \geq 0 \land V < v) \right) \\
        & \ \ \ \ [x_1 \leftarrow y_1, \ldots, x_n \leftarrow y_n] \\
        & \ \ \ \ \land \forall y_1,\ldots,y_n \left( I \land \neg B \implies R \right)[x_1 \leftarrow y_1, \ldots, x_n \leftarrow y_n] \\
\end{align*}
povšimněme si, že již nepoužíváme funkci $\operatorname{wlp}$, ale místo ní používáme funkci $\operatorname{wp}$,
protože již provádíme výpočet nejslabšího předpokladu pro cyklus pomocí úplné korektnosti.
Na začátku je hodnota variantu $V$ uložena do proměnné $v$.
Po provedení těla cyklu jsou zkontrolovány dvě podmínky.
První podmínka zajišťuje, že nová hodnota variantu po provedení iterace je stále kladná ($V \geq 0$)
a druhá podmínka zajišťuje, že hodnota variantu se po provedení iterace snížila ($V < v$, kde $v$ je hodnota variantu před provedením iterace).

% TODO: navazat treba na Frama-c, ze pokud dokazeme takovyto priklad, tak vsechny
% TODO: i nelogicke priklady po tom jsou podminene pravdive, nehlede na to, ze
% TODO: ze nemaji treba splnitelnost = assert \false